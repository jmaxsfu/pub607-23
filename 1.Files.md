# PUB 607 Fundamentals

## On File Management

A file is a **metaphor** for a structured bundle of data in a computer. Files do not actually exist in your computer, or on its hard drive (which is not in fact hard). It's a metaphor that shapes a set of behaviours around how we deal with files. The metaphor is closely related to the idea of "documents," but not exactly equivalent.

The file idea, more or less, dates to the late 1960s, early 1970s, and was popularized through the spread of the Unix operating system (which is still with us). We still think largely in terms of files, although alternative metaphors (or patterns) are becoming more common: streams; queries; things pulled together on the fly out of databases.

Files are typically organized in **Filesystems**; the one we all take for granted is the "hierarchical file system," where there is a hierarchical set of "folders" that uniquely locate and organize files. It seems natural because it's been with us for decades, but it's not natural, and it does NOT have to be this way.

Inside a file is data... typically, the "header" of the file is a bundle of data that identifies the file type and provides some basic metadata so that your operating system (and you) can make sense of it. Following that is a bundle of data that represents the "content" of the file: a text, an image, a sound, your taxes, a set of database relations, or whatever.

For the most part, files are DUMB. They can't *do* anything; they sit there passively until operated on by an **application**, which can open, read, edit, manipulate, and/or save the file.

There are as many **file types** as there are pieces of software, more or less. Which is to say, gazillions of them. File standards are the exceptions, not the rule, and so every different version of a word processor has its own file types. The result is files that end up being unusable, or at least only partially usable, if they aren't used by the exact application that they were designed for.

There are, notably, a handful of important standards, where file types work across a number of different applications and aren't bound to a single app:

**Text files**, made up only of lines of text characters. This was the old standard for Unix files, and these are, handily, mostly human-readable. Sometimes text files have a specific internal format: e.g., .csv spreadsheets.

**Image, sound, and video files** that we pass around on the Internet (JPGs, PNGs, MP3s, MOVs, etc.). Since the early Internet was pluralistic enough to demand **open file formats** that a variety of different tools and applications could all use. These are structured bundles of, for the most part, *sampled* data about images, sounds, etc. More about this below...

**XML files**, which are text files with specific structures expressed in them. XML files are theoretically openable and usable by any XML-aware application. In reality it's not quite so simple.

**Defacto common standards** like .docx files or .pdf files are *sort-of* open and *sort of* interoperable, but they are still largely controlled by Microsoft and Adobe. They have achieved standards-like status because they are ubiquitous.

## So many files! How can I manage?

**File naming** is, for the most part, unregulated. There is a common practice wherein we use a particular 3- or 4-letter code at the end of the filename to indicade the file type (e.g. ".txt" or ".pdf"). But it's not a formal standard; it's just how most people and a fair bit of software recognizes things.

What you put before the **dot** in a file name is up to you. The trouble with this practice, obviously, is that your computer (and your inbox) eventually fills up with `untitled.docx` files or `final.xlsx`, or worse: `FINALfinal.pdf`.

It's pretty common for people to use short, easily typed filenames and then rely on the enclosing folder name for context. This, of course, falls apart as soon as you take the file out of that folder and send it to someone.

Regular computer filesystems, for the most part, do not track the history of changes to files. If I have two files named `final.docx`, I might have a clue about which one is final-er than the other by comparing the date in the file metadata; but that date might only reflect when the file was *sent to me* rather than when it was actually edited. 

There *are* systems for **tracking changes** -- or **versions** -- in files and filesystems, and they are definitely worth using. Generally, this means going to the trouble of doing so, though.

A good old DIY workaround for this is to embed version information directly in the filename, like `final-JMax-Dec13.docx` -- It's hardly foolproof, but it might be better than nothing.

## Content Management concepts and software

Part of what's so successful about the "file" metaphor is that it allows us to think of digital things *as if they were paper documents*. One implication of this practice is that we don't tend to think of a file as existing in more than once place at once. We also don't really think of them as dynamic. If a file changes, we like to think of it as a new version of that file, as opposed to the same file.

**Content management systems** (CMS) break some of these conceptual limitations. Instead of files living in hierarchies of folders -- on my computer, on your computer, in your inbox, or in my inbox -- a CMS keeps a file in one central online place, and anyone who needs to see it, work on it, etc. comes to it, rather than a copy of the file travelling to them. Therefore multiple people can all be accessing the same file at once. That necessitates keeping track of changes to the file -- if you and I are both editing it, what happens, and when?

There are lots of different kinds of content management systems. **Wordpress** is one kind. **Dropbox** is another kind. **Github** is another. Each makes slightly different trade-offs between the kind of flexibility it offers, against how far it breaks the paper-document metaphor. 

**Wordpress** very much keeps a single, centralized copy of a document (for instance, a post), but it makes the change history of that document easy to see and manage. **Dropbox** also keeps a change history, but it mostly hides it away, so your file in Dropbox looks and acts a lot more like a regular old file on your own computer. **Github** has both local files -- in your own folder hierarchy -- and centrally managed files, tracking the change history across all of these (and across multiple users), and keeping all the different versions in sync; it's harder to get your head around initially, but it is super powerful and flexible as a result.



